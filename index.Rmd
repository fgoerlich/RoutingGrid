---
title: "Distancias y Tiempos"
subtitle: "游깵 <br><br> con poblaci칩n en _grid_ <br> y _R_"
author: "Francisco Goerlich"
institute: "Universidad de Valencia e Ivie"
date: "03/03/2023"
output:
  xaringan::moon_reader:
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r setup, include = FALSE}
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(message = FALSE, warning = FALSE, fig.align = "center")
xaringanExtra::use_tachyons()
xaringanExtra::use_tile_view()
xaringanExtra::use_panelset()
```

```{r library, include = FALSE}
library(tidyverse)
library(here)
```

# Prerequisitos... [춰estos!](https://go.uv.es/goerlich/Routing)

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2, out.width = "100%", fig.align = "center"}
knitr::include_graphics("./img/01_MonoFRA.jpg")
```

Cualquier ejercicio de accesibilidad (geogr치fica) tiene (al menos) 3 patas:

1. un **origen** por parte de quien accede,

2. una **ruta**, por alg칰n medio de trasporte determinado, y

3. un **destino** al centro donde se accede.

--

Ya vimos como geocodificar destinos y calcular rutas para un **origen dado**. Le damos ahora una vuelta de tuerca al **origen**.
춰La distribuci칩n de la poblaci칩n!

Mantenemos el resto del marco de an치lisis de la [monograf칤a de accesibilidad](https://www.ivie.es/es_ES/ptproyecto/distribucion-la-poblacion-acceso-los-servicios-publicos/)
con 1 sola alteraci칩n no trivial: 춰los **origenes**!

---

# 쮼s conveniente alterar los or칤genes? **Si**

La **escala de an치lisis** de la [monograf칤a de accesibilidad](https://www.ivie.es/es_ES/ptproyecto/distribucion-la-poblacion-acceso-los-servicios-publicos/) era
**municipal**: [_"...el municipio es un punto, la coordenada de la capital. Impl칤citamente suponemos que la poblaci칩n est치 concentrada en ese punto._"](https://fgoerlich.github.io/Routing/#20)

Esta era la **principal limitaci칩n del trabajo**. La poblaci칩n &ndash;el or칤gen de donde part칤an nuestros c치lculos de rutas&ndash; estaba localizada en un punto del municipio,
de forma que ten칤amos 8 131 puntos de poblaci칩n, tantos como municipios. 

En cierta forma, era si como nuestros destinos no hubieran estado georeferenciados, solo dispusi칠rmos de la informaci칩n del n칰mero de oficinas que existen en cada municipio,
y estas las localiz치ramos en el mismo punto que la poblaci칩n.

**La georeferenciaci칩n de las oficinas ciertamente afina los c치lculos, 춰`r emo::ji("+1")`!, pero no lo suficiente.**

--

쮻isponemos de poblaci칩n georeferenciada? **No**

--

Bueno, el [INE](https://www.ine.es/) **si** a partir del Censo 2021, 춰pero esta informaci칩n nunca ser치 p칰blica!

---

# 쮸lternativas por debajo del municipio?

**Secciones Censales**: Poco 칰tiles fuera del mundo urbano &ndash;el 70% de los municipios tiene una sola secci칩n censal&ndash;.

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2, out.width = "80%", fig.align = "center"}
knitr::include_graphics("./img/02_SSCC46250.jpg")
```

---

# 쮸lternativas por debajo del municipio?

**Secciones Censales**: Su exahustiva cobertura del t칠rmino municipal hace que haya siempre al menos una secci칩n censal residual.

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2, out.width = "80%", fig.align = "center"}
knitr::include_graphics("./img/03_SSCC46258.jpg")
```

---

# 쮸lternativas por debajo del municipio?

**Nomencl치tor**: 쯊enemos coordenadas de los N칰cleos de Poblaci칩n? **Si**. 

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2, out.width = "75%", fig.align = "center"}
knitr::include_graphics("./img/04_Nucleos.jpg")
```

---

# 쮸lternativas por debajo del municipio?

**Nomencl치tor**: 춰Incluso del diseminado! 춰Sorprendente! 

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2, out.width = "75%", fig.align = "center"}
knitr::include_graphics("./img/05_Diseminados.jpg")
```

???

춰Son la de su _Entidad Singular_!
En definitiva, que car치ctar administrativo del Nomencl치tor, junto con el hecho de que son los ayuntamientos los responsables de su gesti칩n,
con pr치cticamente nula armonizaci칩n, hace dif칤cil su utilizaci칩n en este contexto.
Por ejemplo, si miramos a Madrid veremos que solo tiene una Entidad Singular, un n칰cleo y ning칰n diseminado, lo que contrasta con municipios peque침os
y medianos de de Galicia o Asturias que tienen cientos de peque침os n칰cleos y diseminados.

---

# 쮸lternativas por debajo del municipio?

**Grid de poblaci칩n**: 쯊enemos poblaci칩n en formato _grid_? A veces...

춰Est치n en el [GISCO](https://ec.europa.eu/eurostat/web/gisco) de Eurostat!

--

쯈ue es una _grid_ de poblaci칩n? Una cifra de poblaci칩n por celda, 춰independiente de los lindes administrativos!

--

.pull-left[

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2, out.width = "100%", fig.align = "center"}
knitr::include_graphics("./img/06_Grid50197.png")
```

]

--

.pull-right[

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2, out.width = "100%", fig.align = "center"}
knitr::include_graphics("./img/07_Grid46250.png")
```

]

---

# 춰Probemos!

Si la poblaci칩n del municipio estaba concentrada en un punto, 쯗onde est치 la poblaci칩n de la celda a efectos del c치lculo de rutas?

--

.pull-left[

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2, out.width = "120%", fig.align = "center"}
knitr::include_graphics("./img/08_Grid10062.png")
```

]

.pull-right[

<br><br><br><br>

춰En el centro de la celda!

]

<br>

Tendremos una ruta para cada celda, cuyo centro constituye nuestro origen.

_Bussines as usual!_

---

class: inverse, center, middle

# _Get Started_

---

# Problema real

Disponemos del fichero de Oficinas bancarias de diciembre de 2020 del Banco de Espa침a georeferenciado. **Destinos**

Disponemos de una [_grid_ de poblaci칩n para 2018](https://ec.europa.eu/eurostat/web/gisco/geodata/reference-data/population-distribution-demography/geostat). **Origenes**

Disponemos de la [tecnolog칤a para el c치lculo de **rutas**](https://go.uv.es/goerlich/Routing): distancias y tiempos sobre la red de carreteras.

Y queremos estimar la **distancia** y el **tiempo** de acceso de **cada municipio** &ndash;o cualquier otra unidad administrativa&ndash; a la **oficina m치s cercana**.

.bg-washed-green.b--dark-green.ba.bw2.br3.shadow-5.ph4.mt4[

Se trata exactamente del **mismo problema** que resolvimos en la [presentaci칩n anterior](https://go.uv.es/goerlich/Routing) con la 칰nica diferencia que
ahora disponemos de la poblaci칩n en _grid_ en lugar de la poblaci칩n por municipio.

Esta generalizaci칩n permitir치 contestar preguntas m치s interesantes que el de la oficina m치s cercana.

]

---

# Problema real: _Houston, we have a problem_ 

쮺ual es la dimensi칩n de nuestro problema?

**Origenes:** 74 914 celdas con poblaci칩n.

**Destinos:** 22 558 oficinas.

--

La matriz de **O**rigen-**D**estino (OD) tiene 1 689 910 012 celdas a rellenar.

춰Debemos calcular m치s de 1 600 millones de rutas y elegir la 칩ptima para cada celda! 춰Y luego agregarlas a municipios! 춰`r emo::ji("poop")`!

--

Claramente debemos reducir la dimensi칩n de nuestro problema. 춰Ya era necesario reducirlo con los 8 131 municipios!

Debe resultar obvio que **no** podemos resolver este problema con un servidor de rutas remoto: [Cartociudad](https://www.cartociudad.es/portal/),
[Google](https://mapsplatform.google.com/) o [Open Street Maps (OSM)](https://www.openstreetmap.org/#map=6/40.007/-2.488), como hicimos antes.


Tanto por tiempo de c칩mputo o como por coste en algunos casos.

---

# Problema real: _We found a solution_ 춰`r emo::ji("smile")`!

Afortunadamente es posible instalar en local un servidor de rutas basado en [OSM](http://project-osrm.org/) accesible mediante una
librer칤a de [_R_](https://cran.r-project.org/), [osrm](https://cran.r-project.org/web/packages/osrm/osrm.pdf), o atacando directamente
la [API](http://project-osrm.org/docs/v5.24.0/api/#).

춰H칠ctor lo ha instalado de forma exitosa, `r emo::ji("+1")`!

춰Y funciona _smooth as a baby췂s bottom_!

El rendimiento del servidor es de unos 4.5 millones de rutas d칤a.

En la pr치ctica ello significa las funciones que ya ten칤amos nos sirven para c치lculos intensivos abandonando [Cartociudad](https://www.cartociudad.es/portal/) y
[Google](https://mapsplatform.google.com/), y utilizando solo [OSM](https://www.openstreetmap.org/#map=6/40.007/-2.488).

춰Adem치s hacemos los c치lculos en casa!

.footnote[(*) El rendimiento de Cartociudad es de unas 300 000 rutas d칤a y, probablemente, dismininuye con el n칰mero de rutas.]

---

# _Routing_ OSM: Funciones

```{r, eval = FALSE}
# Distancia y Tiempo de Viaje entre 2 puntos (coordenadas)
osm_get_distance <- function (from, to, profile = c("car", "bike", "foot"), server = NULL)

# Distancia y Tiempo de Viaje entre 2 vectores de coordenadas
oms_distance <- function(from, to, profile = c("car", "bike", "foot"), server = NULL)
```

- `osm_get_distance()`: ruta 칰nica entre 2 puntos (coordenadas) en WGS84.

- `oms_distance()`: rutas masivas _pairwise_ entre 2 vectores de puntos (coordenadas), o entre un origen y m칰ltiples destinos o entre m칰ltiples or칤genes y un destino en WGS84.

Calcula rutas en **coche**, a **pie** o en **bicicleta**.

La opci칩n `server` permite acceder a un servidor local.

En ambos casos devuelve un `tibble` con la distancia (en metros), el tiempo de viaje (en segundos) y una variable de _status_: `OK`, `NULL_VALUES` o `code server`.

---

# _Routing_ OSM: Funciones - _tecnicality_

```{r, eval = FALSE}
# snap de coordenadas a la street network
osm_nearest <- function(longitud, latitud, profile = c("car", "bike", "foot"), server = NULL)
```

- `osm_nearest()`: dadas unas coordenadas cualquiera (en WGS84) devuelve las coordenadas (en WGS84) del nodo de la red m치s cercano y su distancia.

La opci칩n `server` permite acceder a un servidor local.

Devuelve un `tibble` con las coordenadas del nodo, longitud y latitud (en WGS84), la distancia (en metros) al nodo de la red m치s cercano y una variable de _status_: `OK`, o `code server`.

---

# _Routing_ OSM: Funciones para pintar las rutas

```{r, eval = FALSE}
# OSM: Ruta entre 2 puntos (coordenadas)
osm_get_route <- function(from, to, profile = c("car", "bike", "foot"), overview = c("full", "simplified"), server = NULL, plot = FALSE)
# OSM: Rutas entre 2 vectores de coordenadas
osm_routing <- function(from, to, profile = c("car", "bike", "foot"), progress = TRUE, overview = c("full", "simplified"), server = NULL, ...)
```

Si queremos pintar las rutas sobre un mapa disponemos de las mismas funciones, pero en lugar de devolver un `tibble` con los resultados de distancia/tiempo
devuelve una _simple feature_ con esos atributos y la geometr칤a de la ruta para operar con ella o pintarla a efectos ilustrativos.

Pero hay que tener en cuenta **dos cuestiones**:

1. Que a pesar de la potencia de c치lculo deberemos reducir la dimensi칩n del problema. Esto nos lleva a la determinaci칩n de las **치reas de influencia**.

2. Que las rutas son de una celda a una oficina &ndash;est칠 o no en el municipio&ndash;. Para obtener resultados municipales debemos arbitrar un mecanismo de agregaci칩n.

???

En ocasiones la reducci칩n de la dimensi칩n es posible por las propias condiciones del problema. Por ejemplo, en el acceso a los hospitales podemos
limitar la b칰squeda de rutas a celdas/hospitales de la misma comunidad, y esto puede ser suficiente para calcular todas las rutas posibles, dada esta restricci칩n.

---

# Cuesti칩n 1: 츼reas de influencia.

Debemos generar 치reas de influencia para cada celda, 춰m치s de 70 mil!, al objeto de ver que oficinas tiene m치s cerca cada celda dentro de un umbral.

쮺omo se han generado las 치reas de influencia en este caso?

Aprovechando esta [idea](https://fgoerlich.github.io/Routing/#30), 춰sustituyendo al [Ivie](https://www.ivie.es/es_ES/) por cada una de las celdas!

춰Ahora es irrelevante si el municipio tiene oficina o no!

.bg-washed-green.b--dark-green.ba.bw2.br3.shadow-5.ph4.mt4[

En el _project_ de [_R_](https://cran.r-project.org/) un _script_ genera una **base de datos de accesibilidad** &ndash;muchas rutas para cada celda&ndash; a partir
de

(_i_) coordenadas de poblaci칩n &ndash;centroides de las celdas de la _grid_&ndash; y

(_ii_) coordenadas de las oficinas,

dados unos par치metros configurables que controlan el 치rea de influencia de cada celda.

]

---

# 츼reas de influencia: Ejemplo

.panelset[

.panel[.panel-name[Celda]

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2, out.width = "78%", fig.align = "center"}
knitr::include_graphics("./img/06_Grid50197.png")
```

]

.panel[.panel-name[츼rea de influencia]

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2, out.width = "78%", fig.align = "center"}
knitr::include_graphics("./img/09_Grid50197.png")
```

]

.panel[.panel-name[Oficinas]

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2, out.width = "78%", fig.align = "center"}
knitr::include_graphics("./img/10_Grid50197.png")
```

]

.panel[.panel-name[Rutas]

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2, out.width = "78%", fig.align = "center"}
knitr::include_graphics("./img/11_Grid50197.png")
```

]

.panel[.panel-name[M치s cercana]

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2, out.width = "78%", fig.align = "center"}
knitr::include_graphics("./img/12_Grid50197.png")
```

]

]

---

# 츼reas de influencia: _script_

```{r, eval = FALSE}
#   Umbral inicial para acotar el n칰mero de rutas (Km)
Threshold <- 50L
#   Incremento del umbral si no se consigue el n칰mero m칤nimo de rutas
Step <- 5L
#   N칰mero m칤nimo de rutas a evaluar
MinRutas <- 20L
```

.bg-washed-green.b--dark-green.ba.bw2.br3.shadow-5.ph4.mt4[

El _script_ toma por defecto un **radio de 50km** alrededor de cada punto de poblaci칩n.
Si el m칤nimo de Oficinas en dicho radio en **menor de 20**, se incrementa en **intervalos de 5km** hasta alcanzar dicho m칤nimo.

Se genera un fichero auxiliar que indica, para cada celda, el n칰mero de rutas evaluadas, el umbral y las distancias/tiempos
m칤nimos y m치ximos.

Las islas, Ceuta y Melilla juegan en una liga aparte.

Se evaluaron 31 790 732 rutas.

]

---

# Cuesti칩n 2: Agregaci칩n

쮺omo paso de las rutas &ndash;distancias/tiempos&ndash; de las celdas a los resultados por municipios &ndash;distancia/tiempo a la oficina m치s cercana&ndash;?

Mediante **promedios ponderados** por la **poblaci칩n** de cada celda del municipio.

춰Solo resultados ponderados tienen sentido aqu칤!

Lo mismo para provincias, Comunidades Aut칩nomas o cualquier otra 치rea, con la salvedad de que **debo partir siempre de las celdas** &ndash;que es la unidad elemental&ndash; **en el proceso de agregaci칩n**.

---

# Agregaci칩n: Ejemplo

.panelset[

.panel[.panel-name[Celdas]

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2, out.width = "78%", fig.align = "center"}
knitr::include_graphics("./img/13_Grid46213.png")
```

]

.panel[.panel-name[Oficinas]

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2, out.width = "78%", fig.align = "center"}
knitr::include_graphics("./img/14_Grid46213.png")
```

]

.panel[.panel-name[츼rea de influencia]

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2, out.width = "78%", fig.align = "center"}
knitr::include_graphics("./img/15_Grid46213.png")
```

]

.panel[.panel-name[Rutas m칤nimas]

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2, out.width = "78%", fig.align = "center"}
knitr::include_graphics("./img/16_Grid46213.png")
```

]

]

---

# La base de datos de accesibilidad

Un n칰mero de rutas tan elevado por celda nos permite contestar otras **preguntas interesantes** adem치s de la distancia y el tiempo de acceso a la oficina m치s cercana.

.bg-washed-green.b--dark-green.ba.bw2.br3.shadow-5.ph4.mt4[

En el _project_ de [_R_](https://cran.r-project.org/) hay 6 _scripts_ que contestan 3 preguntas de inter칠s para 2 치mbitos geogr치ficos diferentes.

**Preguntas de inter칠s**:

1. Distancia/tiempo a la oficina m치s cercana.

2. N칰mero medio de oficinas accesibles en $t$ minutos de tiempo.

3. Poblaci칩n que tiene acceso a $n$ oficinas en $t$ minutos de tiempo.

**츼mbitos geogr치ficos**:

1. Municipios.

2. Grado de urbanizaci칩n por Comunidad Aut칩noma.

]

---

# Oficina m치s cercana por DEGURBA

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2.1, out.width = "70%", fig.align = "center"}
readxl::read_xlsx(here("data", "03AccesibilidadOficinas.xlsx"), sheet = "DEGURBA") %>%
  select(DEGURBA, Distancia = DistanciaW, Tiempo = TiempoW) %>%
  mutate(DEGURBA = factor(DEGURBA, levels = c("Urbano", "Intermedio", "Rural"))) %>%
  pivot_longer(!DEGURBA, names_to = "Variable", values_to = "Valor") %>%
  ggplot(aes(x = DEGURBA, y = Valor, fill = Variable)) +
    geom_bar(stat = "identity", position = position_dodge()) +
    geom_text(aes(label = round(Valor, 1)), position = position_dodge(width = 0.9), vjust = 1.5, color = "white", size = 5) +
    xlab("") + ylab("Distancia en kil칩metros\nTiempo en minutos") +
    ggtitle("Distancia/Tiempo a la oficina m치s cercana \npor grado de urbanizaci칩n") +
    scale_fill_manual(values = c("Distancia" = "darkblue", "Tiempo" = "darkred")) +
    #theme_minimal() +
    theme(legend.position = "bottom", legend.title=element_blank())
```

???

Valores nacionales:
   Distancia: 1.3 (sd = 2.2)
   Tiempo:    2.3 (sd = 2.9)

---

# Oficinas accesibles en 15m por DEGURBA

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2.1, out.width = "70%", fig.align = "center"}
readxl::read_xlsx(here("data", "05AccesibilidadOficinas.xlsx"), sheet = "DEGURBA") %>%
  select(DEGURBA, Oficinas = nOfiW) %>%
  mutate(DEGURBA = factor(DEGURBA, levels = c("Urbano", "Intermedio", "Rural"))) %>%
  ggplot(aes(x = DEGURBA, y = Oficinas)) +
    geom_bar(stat = "identity", fill = "darkblue") +
    geom_text(aes(label = round(Oficinas, 0)), position = position_dodge(width = 0.9), vjust = 1.2, color = "white", size = 5) +
    xlab("") + ylab("N칰mero de oficinas") +
    ggtitle("Oficinas accesibles en una isocrona de 15m \npor grado de urbanizaci칩n")
```

???

Valor nacional: 208 (sd = 319)
   
---

## Oficinas accesibles en una isocrona de 15m por CCAA

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2.1, out.width = "70%", fig.align = "center"}
readxl::read_xlsx(here("data", "05AccesibilidadOficinas.xlsx"), sheet = "CCAA") %>%
  select(`C칩digo`= CodCCAA, CCAA, Oficinas = nOfiW) %>%
  DT::datatable(options = list(dom = "frtip", pageLength = 8)) %>%
  DT::formatRound("Oficinas", digits = 0, mark = ",")
```

???

Valor nacional: 208 (sd = 319)

---

### Poblaci칩n con al menos 1 oficina accesible en 15m por municipio

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2.1, out.width = "70%", fig.align = "center"}
readxl::read_xlsx(here("data", "06AccesibilidadOficinas.xlsx"), sheet = "Municipios") %>%
  select(Provincia, CodMuni, Municipio, POBAcceso, POBNOAcceso) %>%
  rename(`C칩digo` = CodMuni, `Con Acceso`= POBAcceso, `Sin Acceso` = POBNOAcceso) %>%
  DT::datatable(extensions = 'Buttons', options = list(dom = "Bfrtip", pageLength = 5, buttons = c('csv', 'excel', 'pdf', 'print'))) %>%
  DT::formatRound("Con Acceso", digits = 1, mark = ",") %>%
  DT::formatRound("Sin Acceso", digits = 1, mark = ",")
```

???

Valor nacional:
  Poblaci칩n **con** acceso: 99%
  Poblaci칩n **sin** acceso:  1%

---

# El fichero de poblaci칩n en _grid_ (1/2)

Si examin치is el contenido de una _grid_ de poblaci칩n ver칠is, m치s o menos, esto

```{r, echo = FALSE, eval = TRUE, fig.asp = 2/2, out.width = "35%", fig.align = "center"}
knitr::include_graphics("./img/17_Grid.jpg")
```

en ocasiones una simple tabla, a veces esa misma informaci칩n en formato _GIS_ (vectorial), pero normalmente solo contiene un **identificador
de celda** y la **cifra de poblaci칩n**. 춰Si el formato es _GIS_ pod칠is pintar la _grid_!

.bg-washed-green.b--dark-green.ba.bw2.br3.shadow-5.ph4.mt4[

El [sistema de _grids_ europeo](https://inspire.ec.europa.eu/id/document/tg/gg) est치 normalizado, y su Sistema de Referencia de Coordenadas (_CRS_) es [ETRS89-LAEA](https://epsg.io/3035).

Al servidor de rutas hemos de mandar coordenadas puntuales en _CRS_ [WGS84](https://epsg.io/4326).

Este paso **no** est치 en el _project_ de [_R_](https://cran.r-project.org/), **es previo**. El _project_ parte de unas coordenadas puntuales en [WGS84](https://epsg.io/4326) para cada cifra de poblaci칩n.

]

---

# El fichero de poblaci칩n en _grid_ (2/2)

En los ficheros de _grid_ no hay ni rastro de los municipios, las provincias o las CCAA. 춰Sin embargo ese, u otro parecido, es nuestro objetivo final!

La _grid_ es simplemente una **geometr칤a intermedia de c치lculo** que nos permite aumentar la resoluci칩n &ndash;m치s modernamente granularidad&ndash; de los resultados.

쮺omo paso de las celdas de la _grid_ a lo que a mi me interesa &ndash;municipios&ndash;?

La soluci칩n [aqu칤](https://go.uv.es/goerlich/GridStatistics). `r emo::ji("+1")`

.bg-washed-green.b--dark-green.ba.bw2.br3.shadow-5.ph4.mt4[

Este paso **tampoco** est치 en el _project_ de [_R_](https://cran.r-project.org/), **tambi칠n es previo** y requiere de algo trabajo con capas _GIS_.

Para acometer el ejercicio de rutas hubo que (_i_) convertir la _grid_ en coordenadas puntuales en otro _CRS_ y (_ii_) establecer la relaci칩n entre cada celda y la unidad administrativa a la que pertenece, de la misma forma que antes de empezar tuvimos que geocodificar las oficinas.

]

---

background-image: url(https://www.ivie.es/wp-content/uploads/2017/02/logo.jpg), url(https://www.uv.es/recursos/fatwirepub/css/logoPeu.png)
background-position: 95% 5%, 5% 95%
background-size: 12%, 20%

class: center, middle

# 춰Gracias por la atenci칩n!

## .green[쯇reguntas?]

???

Slides created via the R package [**xaringan**](https://github.com/yihui/xaringan).
